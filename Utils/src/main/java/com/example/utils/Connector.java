package com.example.utils;

import com.example.utils.news.News;
import com.example.utils.news.NewsApi;
import com.example.utils.news.NewsData;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.solace.messaging.MessagingService;
import com.solace.messaging.PubSubPlusClientException;
import com.solace.messaging.config.MissingResourcesCreationConfiguration;
import com.solace.messaging.config.SolaceProperties;
import com.solace.messaging.config.profile.ConfigurationProfile;
import com.solace.messaging.publisher.DirectMessagePublisher;
import com.solace.messaging.publisher.OutboundMessage;
import com.solace.messaging.publisher.OutboundMessageBuilder;
import com.solace.messaging.publisher.PersistentMessagePublisher;
import com.solace.messaging.receiver.DirectMessageReceiver;
import com.solace.messaging.receiver.PersistentMessageReceiver;
import com.solace.messaging.resources.Queue;
import com.solace.messaging.resources.Topic;
import com.solace.messaging.resources.TopicSubscription;
import com.solace.messaging.util.Converter.ObjectToBytes;
import com.solace.messaging.util.Converter.BytesToObject;
import org.springframework.beans.factory.DisposableBean;

import java.io.IOException;
import java.util.List;
import java.util.Properties;
import java.util.function.Consumer;

/**
 * This is a class of Solace Event Broker API I extracted from the Solace API
 * <a href="https://docs.solace.com/Get-Started/get-started-lp.htm">Link</a>
 * This class has the simplest function to publish / receive -> direct / persistent messages
 */
public class Connector implements DisposableBean {

    private static final String TOPIC_PREFIX = "subscriptions/";  // used as the topic "root"

    // Create this beforehand!
    private static final String QUEUE_NAME = "subscription";

    // The guy talks to the Event Broker himself
    private final MessagingService messagingService;

    // Publishers and Receivers
    private final DirectMessagePublisher directMessagePublisher;
    private final DirectMessageReceiver directMessageReceiver;
    private final PersistentMessagePublisher persistentMessagePublisher;

    private final PersistentMessageReceiver persistentMessageReceiver;

    public Connector(String host, String vpn, String username, String password) {
        // Mandatory fields
        final Properties properties = new Properties();
        // host:port
        properties.setProperty(SolaceProperties.TransportLayerProperties.HOST, host);
        // message-vpn
        properties.setProperty(SolaceProperties.ServiceProperties.VPN_NAME,  vpn);
        // client-username
        properties.setProperty(SolaceProperties.AuthenticationProperties.SCHEME_BASIC_USER_NAME, username);
        // client-password
        properties.setProperty(SolaceProperties.AuthenticationProperties.SCHEME_BASIC_PASSWORD, password);
        // recommended settings
        properties.setProperty(SolaceProperties.TransportLayerProperties.RECONNECTION_ATTEMPTS, "20");
        properties.setProperty(SolaceProperties.TransportLayerProperties.CONNECTION_RETRIES_PER_HOST, "5");

        // The service to connect with Solace Event Broker
        messagingService = MessagingService.builder(ConfigurationProfile.V1)
                .fromProperties(properties)
                .build();

        // Direct
        directMessagePublisher = messagingService
                .createDirectMessagePublisherBuilder()
                .build();

        directMessageReceiver = messagingService
                .createDirectMessageReceiverBuilder()
                // Dynamic Topic! Accept everything on the next Topic level
                .withSubscriptions(TopicSubscription.of("news/*"))
                .build();

        /*
            Solace ÁöÑ QueueÊòØËøôÊ†∑Â∑•‰ΩúÁöÑÔºöTopic to Queue
            1. È¶ñÂÖà Publisher ÈúÄË¶ÅÂà∂ÂÆö‰∏Ä‰∏™ÁõÆÊ†á TopicÔºåÁÑ∂ÂêéÂ∞ÜÊ∂àÊÅØÂèëÈÄÅÂà∞Ëøô‰∏™ Topic‰∏äÔºå‰∏çÈúÄË¶ÅÂà∂ÂÆö Queue
            2. ÁÑ∂Âêé Receiver ÈúÄË¶ÅÁªëÂÆöÂà∞‰∏Ä‰∏™ QueueÔºå‰∏çÈúÄË¶ÅÂà∂ÂÆö Topic
            3. ‰ΩÜÊòØ Ëøô‰∏™ Queue ÂøÖÈ°ªË¶ÅÂà∂ÂÆöÊÑüÂÖ¥Ë∂£ÁöÑ TopicÔºÅÊâãÂä®ÊåáÂÆö
            4. ÁÑ∂Âêé receiver Â∞±‰ºöÊé•Êî∂Âà∞Ëøô‰∏™ Queue ÈáåÊâÄÊúâÊÑüÂÖ¥Ë∂£ÁöÑ Topic ÁöÑÊ∂àÊÅØ

            ÁªèÈ™åÔºö
            1. Â∞ΩÈáèËÆ© Queue exclusiveÔºåÂè™ËÉΩÊúâ‰∏Ä‰∏™Ê∂àË¥πËÄÖ
            2. ÂêØÂä® Receiver ÁöÑ Ëá™Âä®ÂàõÂª∫ Queue ÁöÑÈÖçÁΩÆ
         */

        // Persistent
        persistentMessagePublisher = messagingService
                .createPersistentMessagePublisherBuilder()
                .build();

        persistentMessageReceiver = messagingService
            .createPersistentMessageReceiverBuilder()
            .withMissingResourcesCreationStrategy(
                    // Â¶ÇÊûú Broker Ê≤°ÊúâÂ∫ï‰∏ã build() ÈáåÈÖçÁΩÆÁöÑ QueueÔºåÂêØÂä®Êó∂Ëá™Âä®ÂàõÂª∫
                    MissingResourcesCreationConfiguration.MissingResourcesCreationStrategy.CREATE_ON_START)
            .build(Queue.durableExclusiveQueue(QUEUE_NAME));
    }

    public void connect() {
        messagingService.connect();  // blocking connect to the broker
    }

    // Make sure called after connect()
    public void startDirectPublisher() {
        // Start the publisher
        directMessagePublisher.startAsync(
            // Every Async excepts a CompletionListener, and this is a Functional interface
            (publisher, throwable) -> {
                // If there's an error occurred during start
                if (throwable != null) {
                    throw new RuntimeException(
                            String.format("Failed to start directMessagePublisher due to: %s", throwable.getCause())
                    );
                } else {
                    // Start successfully, start publishing
                    System.out.println("Publisher starts successfully!");
                }
            }
        );
    }

    // Make sure called after connect()
    public void startDirectReceiver() {
        // Blocking start
        directMessageReceiver.start();
        System.out.println("DirectMessageReceiver starts successfully!");
    }

    public void disconnect() {
        if (messagingService != null) {
            messagingService.disconnect();
        }
    }

    // Ë¥üË¥£Â∞Ü News instance ËΩ¨Êç¢Êàê Bytes ËøõË°åÁΩëÁªú‰º†ËæìÔºÅ
    public ObjectToBytes<News> getNewsToBytesConverter(){
        return newsApi -> {
            try{
                ObjectMapper mapper = new ObjectMapper();
                // Add this line to support Instant data type
                // maintain UTC time when sending to the broker
                mapper.registerModule(new JavaTimeModule());
                return mapper.writeValueAsBytes(newsApi);
            } catch (JsonProcessingException e) {
                throw new RuntimeException("Cannot process JSON", e);
            } catch (RuntimeException e){
                throw new RuntimeException("Failed to convert News to bytes", e);
            }
        };
    }

    // ËΩ¨Êç¢ÂõûÊù•
    public <T extends News> BytesToObject<T> getBytesToNewsConverter(Class<T> clazz) {
        // bytes are the payload, will be called by Solace and convert them into News
        return bytes -> {
            try {
                ObjectMapper mapper = new ObjectMapper();
                mapper.registerModule(new JavaTimeModule());
                return mapper.readValue(bytes, clazz);
            } catch (IOException e) {
                throw new RuntimeException("Cannot process JSON", e);
            }
        };
    }


    // Publish a list of same source of news to a Topic
    // newsType Áî®Êù•Ëæ®Âà´ÊòØ NewsAPI ËøòÊòØ NewsData ÂèëÂ∏ÉÁöÑÔºåÂØπ‰∫éÊé•Êî∂ÊñπÊúâÂ∏ÆÂä©
    public void publishDirect(List<News> newsList, String newsType, String topic){
        // Since News is an object, we need to convert into bytes to send to the Broker
        ObjectToBytes<News> newsConverter = getNewsToBytesConverter();
        // Create the message builder for best practise
        OutboundMessageBuilder outboundMessageBuilder = messagingService.messageBuilder();

        // Set a failure listener
        directMessagePublisher.setPublishFailureListener(
            (failedPublishEvent) -> {
                System.out.println("Failed to send message: ");
                System.out.println(failedPublishEvent);
            }
        );

        for (News newsItem : newsList) {
            // Construct the message, extra properties allows granular control
            OutboundMessage message = outboundMessageBuilder
                    .withProperty("News type", newsType)
                    .build(newsItem, newsConverter);
            System.out.println("üì§ Sending message: ");
            System.out.println(message.getPayloadAsString());

            try {
                directMessagePublisher.publish(message, Topic.of(topic));
            } catch (PubSubPlusClientException e) {
                throw new PubSubPlusClientException(e);
            } catch (IllegalStateException e) {
                throw new IllegalArgumentException(e);
            } catch (RuntimeException e) {
                throw new RuntimeException(e);
            }
        }

    }

    // Keep receiving messages from the Topic "news/*"
    public void receiveDirect(Consumer<NewsApi> onNewAPIReceived, Consumer<NewsData> onNewsDataReceived) {
        // ÂêØÂä®‰∏Ä‰∏™ async ÂºÇÊ≠•Á∫øÁ®ãÔºåÂè™ËÉΩË¢´ÂêØÂä®‰∏ÄÊ¨°ÔºåÁî®Êù•Êé•Êî∂Ê∂àÊÅØ
        directMessageReceiver.receiveAsync(
            inboundMessage -> {
                // Successfully received messages!
                String newsType = inboundMessage.getProperty("News type");
                News news = null;
                // Different News type!
                System.out.println("üíåMessage received!");

                if (newsType.equals("NewsData")) {
                    // ËÆ© NewsData Callback Êù•Â§ÑÁêÜ
                    BytesToObject<NewsData> bytesToNewsConverter = getBytesToNewsConverter(NewsData.class);
                    news = inboundMessage.getAndConvertPayload(bytesToNewsConverter, NewsData.class);
                    // Receiver will save the news to the news data list
                    onNewsDataReceived.accept((NewsData) news);
                } else if (newsType.equals("NewsAPI")) {
                    // ËÆ© NewsAPI Callback Êù•Â§ÑÁêÜ
                    BytesToObject<NewsApi> bytesToNewsConverter = getBytesToNewsConverter(NewsApi.class);
                    news = inboundMessage.getAndConvertPayload(bytesToNewsConverter, NewsApi.class);
                    // Receiver will save the news to the news api list
                    onNewAPIReceived.accept((NewsApi) news);
                }
                System.out.println(news);
            }
        );

    }

    /*
        Persistent
     */
    public void startPersistentPublisher() {
        persistentMessagePublisher.startAsync(
            (onCompletionListener, throwable) -> {
                if (throwable != null) {
                    throw new RuntimeException(
                            String.format("Failed to start persistentMessagePublisher due to: %s", throwable.getCause())
                    );
                } else {
                    System.out.println("PersistentMessagePublisher starts successfully!");
                }
            }
        );
    }

    public void startPersistentReceiver() {
        persistentMessageReceiver.startAsync(
            (onCompletionListener, throwable) -> {
                if (throwable != null) {
                    throw new RuntimeException(
                            String.format("Failed to start persistentMessageReceiver due to: %s", throwable.getCause())
                    );
                } else {
                    System.out.println("PersistentMessageReceiver starts successfully!");
                }
            }
        );
    }


    /*
     Payload ÊòØÊñ∞ÈóªÊú¨Ë∫´ÔºåtopicSuffix ÊòØ Topic ÁöÑË∑ØÂæÑÔºåÁî®Êù•ÈôÑÁùÄÂà∞ÊúÄÂêé‰∏ÄÁ∫ßÁöÑ Topic Ë∑ØÂæÑ‰∏ä
     ËÄå‰∏î Queue ÈáåÊòØÁî® news/* Êù•ÂåπÈÖçÁöÑÔºåÊâÄ‰ª•‰ªª‰ΩïËøô‰∏ÄÁ∫ßÁöÑ News ÈÉΩ‰ºöË¢´ÊåÅ‰πÖÂåñÂà∞ Broker ‰∏ä
     */
    public void publishPersistent(News payload, String topicSuffix){
        // Âª∫Á´ã OutboundMessage
        OutboundMessageBuilder messageBuilder = messagingService.messageBuilder();
        ObjectToBytes<News> newsConverter = getNewsToBytesConverter();
        String newsType = payload instanceof NewsApi ? "NewsAPI" : "NewsData";

        try{
            OutboundMessage message = messageBuilder
                    .withProperty("News type", newsType)
                    .build(payload, newsConverter);

            System.out.println("üì§ Sending persistent message: ");
            System.out.println(message.getPayloadAsString());
            // Specify Topic name, dynamic Topic!
            String topicString = new StringBuilder(TOPIC_PREFIX)
                    .append("news/")
                    .append(topicSuffix) // ËøôÈáå
                    .toString();
            try {
                persistentMessagePublisher.publish(message,Topic.of(topicString));
            } catch (PubSubPlusClientException e) {
                System.out.printf("Fail to publish message: %s - %s\n", message, e);
            }
            System.out.printf("Message %s sent successfully\n", payload);
        } catch (RuntimeException e) {
            System.out.printf("### Caught while trying to publisher.publish() %s\n",e);
        }
    }

    // JS Á´ØËá™Â∑±Â§ÑÁêÜÊé•Êî∂ÔºåËøôÈáåÁöÑ Receiver ÊòØ‰∏∫‰∫ÜÊé•Êî∂Âà´ÁöÑÂæÆÊúçÂä°ÂèëÊù•ÁöÑÔºåÊöÇÊó∂Áî®‰∏çÂà∞
    public void receivePersistent(Consumer<NewsApi> onNewAPIReceived, Consumer<NewsData> onNewsDataReceived) {
        persistentMessageReceiver.receiveAsync(inboundMessage -> {
            /*
                Redelivery ËØ¥Êòéqueue‰∏≠ÁöÑÊ∂àÊÅØË¢´ÂèëÁªôÊ∂àË¥πËÄÖÔºå‰ΩÜÊòØÊ≤°ÊúâË¢´ÊàêÂäüÊé•Êî∂
                ÂèØËÉΩÁöÑÂéüÂõ†Ôºö
                1. ‰ΩÜÊ≤°Êúâ ack ÔºåÂ∞±‰ºöËß¶Âèë redelivery
                2. Ê∂àË¥πËÄÖÂ§ÑÁêÜÊ∂àÊÅØÂêéÂ¥©Ê∫É, ack Ê≤°Êú∫‰ºöÂèëÂá∫ÔºåBroker ‰ª•‰∏∫Â§±Ë¥•
                3. Â¶ÇÊûú receiver Âè™ÊòØÈìæÊé•‰∏äÔºå‰ΩÜÊ≤°Êúâ‰ªª‰ΩïË°å‰∏∫Ôºå‰ΩÜËøôÊó∂ÂÄô publisher ‰æùÁÑ∂ÂèëÈÄÅ‰∫ÜÔºå
                    broker ‰πü‰ºöÊäïÈÄíÁªô consumerÔºå‰ΩÜÊòØÂõ†‰∏∫ receiver Ê≤°Êúâ‰ªª‰ΩïÊ∂àË¥πÊÑèÂõæÔºåÊâÄ‰ª•ÊäïÈÄíÂ§±Ë¥•
                    ÁÑ∂Âêé‰∏ã‰∏ÄÊ¨°ÂÜçÊé•Êî∂ÁöÑÊó∂ÂÄôÂ∞±‰ºöËß¶Âèë redelivery. ÊâÄ‰ª•Â∞ΩÈáè‰øùËØÅ receiver Âíå publisher
                    ÂêåÊó∂Âú®Á∫øÔºÅ
             */
            if (inboundMessage.isRedelivered()) {
                System.err.println("*** Redelivery detected, please call the ack() or check receiver connection. ***");
            }
            // Successfully received messages!
            String newsType = inboundMessage.getProperty("News type");
            News news = null;
            System.out.println("Persistent message type: ");
            System.out.println(newsType);

            // Must acknowledge the message!
            persistentMessageReceiver.ack(inboundMessage);

            if (newsType.equals("NewsData")) {
                BytesToObject<NewsData> bytesToNewsConverter = getBytesToNewsConverter(NewsData.class);
                news = inboundMessage.getAndConvertPayload(bytesToNewsConverter, NewsData.class);
                // Receiver will save the news to the news data list
                onNewsDataReceived.accept((NewsData) news);
            } else if (newsType.equals("NewsAPI")) {
                BytesToObject<NewsApi> bytesToNewsConverter = getBytesToNewsConverter(NewsApi.class);
                news = inboundMessage.getAndConvertPayload(bytesToNewsConverter, NewsApi.class);
                // Receiver will save the news to the news api list
                onNewAPIReceived.accept((NewsApi) news);
            }
            System.out.println(news);
        });
    }

    // Disconnect from the broker once the bean is destroyed
    @Override
    public void destroy() {
        directMessagePublisher.terminate(1000L);
        System.out.println("Direct Publisher terminated");

        directMessageReceiver.terminate(1000L);
        System.out.println("Direct Receiver terminated");

        persistentMessagePublisher.terminate(1500L);
        System.out.println("Persistent Publisher terminated.");

        persistentMessageReceiver.terminate(1500L);
        System.out.println("Persistent Receiver terminated.");

        System.out.println("Disconnecting from event broker...");
        disconnect();
        System.out.println("Done");
    }
}
